//
// Generated by Bluespec Compiler, version 2025.01.1-14-g36da7029 (build 36da7029)
//
// On Mon Dec 15 22:02:56 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_multiply                   O     1
// get_multiply                   O    32 reg
// RDY_get_multiply               O     1
// RDY_mac                        O     1
// get_mac                        O    32 reg
// RDY_get_mac                    O     1
// RDY_clear_accumulator          O     1
// busy                           O     1 reg
// RDY_busy                       O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// multiply_a                     I    32
// multiply_b                     I    32
// mac_a                          I    32
// mac_b                          I    32
// EN_multiply                    I     1
// EN_mac                         I     1
// EN_clear_accumulator           I     1
// EN_get_multiply                I     1 unused
// EN_get_mac                     I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMAC(CLK,
	     RST_N,

	     multiply_a,
	     multiply_b,
	     EN_multiply,
	     RDY_multiply,

	     EN_get_multiply,
	     get_multiply,
	     RDY_get_multiply,

	     mac_a,
	     mac_b,
	     EN_mac,
	     RDY_mac,

	     EN_get_mac,
	     get_mac,
	     RDY_get_mac,

	     EN_clear_accumulator,
	     RDY_clear_accumulator,

	     busy,
	     RDY_busy);
  input  CLK;
  input  RST_N;

  // action method multiply
  input  [31 : 0] multiply_a;
  input  [31 : 0] multiply_b;
  input  EN_multiply;
  output RDY_multiply;

  // actionvalue method get_multiply
  input  EN_get_multiply;
  output [31 : 0] get_multiply;
  output RDY_get_multiply;

  // action method mac
  input  [31 : 0] mac_a;
  input  [31 : 0] mac_b;
  input  EN_mac;
  output RDY_mac;

  // actionvalue method get_mac
  input  EN_get_mac;
  output [31 : 0] get_mac;
  output RDY_get_mac;

  // action method clear_accumulator
  input  EN_clear_accumulator;
  output RDY_clear_accumulator;

  // value method busy
  output busy;
  output RDY_busy;

  // signals for module outputs
  wire [31 : 0] get_mac, get_multiply;
  wire RDY_busy,
       RDY_clear_accumulator,
       RDY_get_mac,
       RDY_get_multiply,
       RDY_mac,
       RDY_multiply,
       busy;

  // register accumulator
  reg [31 : 0] accumulator;
  wire [31 : 0] accumulator$D_IN;
  wire accumulator$EN;

  // register computing
  reg computing;
  wire computing$D_IN, computing$EN;

  // register current_op
  reg [1 : 0] current_op;
  reg [1 : 0] current_op$D_IN;
  wire current_op$EN;

  // register cycle_count
  (* fsm_encoding = "none" *) reg [1 : 0] cycle_count;
  wire [1 : 0] cycle_count$D_IN;
  wire cycle_count$EN;

  // register mult_stage
  reg [63 : 0] mult_stage;
  reg [63 : 0] mult_stage$D_IN;
  wire mult_stage$EN;

  // register result_reg
  reg [31 : 0] result_reg;
  reg [31 : 0] result_reg$D_IN;
  wire result_reg$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_do_multiply;

  // remaining internal signals
  wire [127 : 0] SEXT_mac_a_6_MUL_SEXT_mac_b_7___d28,
		 SEXT_multiply_a_0_MUL_SEXT_multiply_b_1___d22;
  wire [63 : 0] SEXT_mult_stage_BITS_63_TO_16__q2;
  wire [47 : 0] mult_stage_BITS_63_TO_16__q1;
  wire [31 : 0] accumulator_4_PLUS_mult_stage_1_SRA_16_2_BITS__ETC___d15;

  // action method multiply
  assign RDY_multiply = !computing ;

  // actionvalue method get_multiply
  assign get_multiply = result_reg ;
  assign RDY_get_multiply = !computing ;

  // action method mac
  assign RDY_mac = !computing ;

  // actionvalue method get_mac
  assign get_mac = result_reg ;
  assign RDY_get_mac = !computing ;

  // action method clear_accumulator
  assign RDY_clear_accumulator = !computing ;

  // value method busy
  assign busy = computing ;
  assign RDY_busy = 1'd1 ;

  // rule RL_do_multiply
  assign WILL_FIRE_RL_do_multiply = computing && cycle_count == 2'd1 ;

  // register accumulator
  assign accumulator$D_IN =
	     (current_op == 2'd1) ?
	       accumulator_4_PLUS_mult_stage_1_SRA_16_2_BITS__ETC___d15 :
	       32'd0 ;
  assign accumulator$EN =
	     WILL_FIRE_RL_do_multiply &&
	     (current_op == 2'd1 || current_op == 2'd2) ;

  // register computing
  assign computing$D_IN = !WILL_FIRE_RL_do_multiply ;
  assign computing$EN =
	     WILL_FIRE_RL_do_multiply || EN_clear_accumulator || EN_mac ||
	     EN_multiply ;

  // register current_op
  always@(EN_multiply or EN_mac or EN_clear_accumulator)
  begin
    case (1'b1) // synopsys parallel_case
      EN_multiply: current_op$D_IN = 2'd0;
      EN_mac: current_op$D_IN = 2'd1;
      EN_clear_accumulator: current_op$D_IN = 2'd2;
      default: current_op$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign current_op$EN = EN_multiply || EN_mac || EN_clear_accumulator ;

  // register cycle_count
  assign cycle_count$D_IN = WILL_FIRE_RL_do_multiply ? 2'd0 : 2'd1 ;
  assign cycle_count$EN =
	     WILL_FIRE_RL_do_multiply || EN_clear_accumulator || EN_mac ||
	     EN_multiply ;

  // register mult_stage
  always@(EN_multiply or
	  SEXT_multiply_a_0_MUL_SEXT_multiply_b_1___d22 or
	  EN_mac or
	  SEXT_mac_a_6_MUL_SEXT_mac_b_7___d28 or EN_clear_accumulator)
  begin
    case (1'b1) // synopsys parallel_case
      EN_multiply:
	  mult_stage$D_IN =
	      SEXT_multiply_a_0_MUL_SEXT_multiply_b_1___d22[63:0];
      EN_mac: mult_stage$D_IN = SEXT_mac_a_6_MUL_SEXT_mac_b_7___d28[63:0];
      EN_clear_accumulator: mult_stage$D_IN = 64'd0;
      default: mult_stage$D_IN =
		   64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign mult_stage$EN = EN_multiply || EN_mac || EN_clear_accumulator ;

  // register result_reg
  always@(current_op or
	  SEXT_mult_stage_BITS_63_TO_16__q2 or
	  accumulator_4_PLUS_mult_stage_1_SRA_16_2_BITS__ETC___d15)
  begin
    case (current_op)
      2'd0: result_reg$D_IN = SEXT_mult_stage_BITS_63_TO_16__q2[31:0];
      2'd1:
	  result_reg$D_IN =
	      accumulator_4_PLUS_mult_stage_1_SRA_16_2_BITS__ETC___d15;
      default: result_reg$D_IN = 32'd0;
    endcase
  end
  assign result_reg$EN =
	     WILL_FIRE_RL_do_multiply &&
	     (current_op == 2'd0 || current_op == 2'd1 ||
	      current_op == 2'd2) ;

  // remaining internal signals
  assign SEXT_mac_a_6_MUL_SEXT_mac_b_7___d28 =
	     { {32{mac_a[31]}}, mac_a } * { {32{mac_b[31]}}, mac_b } ;
  assign SEXT_mult_stage_BITS_63_TO_16__q2 =
	     { {16{mult_stage_BITS_63_TO_16__q1[47]}},
	       mult_stage_BITS_63_TO_16__q1 } ;
  assign SEXT_multiply_a_0_MUL_SEXT_multiply_b_1___d22 =
	     { {32{multiply_a[31]}}, multiply_a } *
	     { {32{multiply_b[31]}}, multiply_b } ;
  assign accumulator_4_PLUS_mult_stage_1_SRA_16_2_BITS__ETC___d15 =
	     accumulator + SEXT_mult_stage_BITS_63_TO_16__q2[31:0] ;
  assign mult_stage_BITS_63_TO_16__q1 = mult_stage[63:16] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        accumulator <= `BSV_ASSIGNMENT_DELAY 32'd0;
	computing <= `BSV_ASSIGNMENT_DELAY 1'd0;
	current_op <= `BSV_ASSIGNMENT_DELAY 2'd0;
	cycle_count <= `BSV_ASSIGNMENT_DELAY 2'd0;
	mult_stage <= `BSV_ASSIGNMENT_DELAY 64'd0;
	result_reg <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (accumulator$EN)
	  accumulator <= `BSV_ASSIGNMENT_DELAY accumulator$D_IN;
	if (computing$EN) computing <= `BSV_ASSIGNMENT_DELAY computing$D_IN;
	if (current_op$EN)
	  current_op <= `BSV_ASSIGNMENT_DELAY current_op$D_IN;
	if (cycle_count$EN)
	  cycle_count <= `BSV_ASSIGNMENT_DELAY cycle_count$D_IN;
	if (mult_stage$EN)
	  mult_stage <= `BSV_ASSIGNMENT_DELAY mult_stage$D_IN;
	if (result_reg$EN)
	  result_reg <= `BSV_ASSIGNMENT_DELAY result_reg$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    accumulator = 32'hAAAAAAAA;
    computing = 1'h0;
    current_op = 2'h2;
    cycle_count = 2'h2;
    mult_stage = 64'hAAAAAAAAAAAAAAAA;
    result_reg = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMAC

