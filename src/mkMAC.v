//
// Generated by Bluespec Compiler, version 2025.01.1-14-g36da7029 (build 36da7029)
//
// On Sun Jan 11 18:37:43 IST 2026
//
//
// Ports:
// Name                         I/O  size props
// RDY_multiply                   O     1
// get_multiply                   O    32 reg
// RDY_get_multiply               O     1 reg
// RDY_mac                        O     1
// get_mac                        O    32 reg
// RDY_get_mac                    O     1 reg
// RDY_clear_accumulator          O     1
// busy                           O     1
// RDY_busy                       O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// multiply_a                     I    32
// multiply_b                     I    32
// mac_a                          I    32
// mac_b                          I    32
// EN_multiply                    I     1
// EN_mac                         I     1
// EN_clear_accumulator           I     1
// EN_get_multiply                I     1
// EN_get_mac                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMAC(CLK,
	     RST_N,

	     multiply_a,
	     multiply_b,
	     EN_multiply,
	     RDY_multiply,

	     EN_get_multiply,
	     get_multiply,
	     RDY_get_multiply,

	     mac_a,
	     mac_b,
	     EN_mac,
	     RDY_mac,

	     EN_get_mac,
	     get_mac,
	     RDY_get_mac,

	     EN_clear_accumulator,
	     RDY_clear_accumulator,

	     busy,
	     RDY_busy);
  input  CLK;
  input  RST_N;

  // action method multiply
  input  [31 : 0] multiply_a;
  input  [31 : 0] multiply_b;
  input  EN_multiply;
  output RDY_multiply;

  // actionvalue method get_multiply
  input  EN_get_multiply;
  output [31 : 0] get_multiply;
  output RDY_get_multiply;

  // action method mac
  input  [31 : 0] mac_a;
  input  [31 : 0] mac_b;
  input  EN_mac;
  output RDY_mac;

  // actionvalue method get_mac
  input  EN_get_mac;
  output [31 : 0] get_mac;
  output RDY_get_mac;

  // action method clear_accumulator
  input  EN_clear_accumulator;
  output RDY_clear_accumulator;

  // value method busy
  output busy;
  output RDY_busy;

  // signals for module outputs
  wire [31 : 0] get_mac, get_multiply;
  wire RDY_busy,
       RDY_clear_accumulator,
       RDY_get_mac,
       RDY_get_multiply,
       RDY_mac,
       RDY_multiply,
       busy;

  // register accumulator
  reg [31 : 0] accumulator;
  wire [31 : 0] accumulator$D_IN;
  wire accumulator$EN;

  // register busy_mac
  reg busy_mac;
  wire busy_mac$D_IN, busy_mac$EN;

  // register busy_multiply
  reg busy_multiply;
  wire busy_multiply$D_IN, busy_multiply$EN;

  // register mac_result
  reg [31 : 0] mac_result;
  wire [31 : 0] mac_result$D_IN;
  wire mac_result$EN;

  // register multiply_result
  reg [31 : 0] multiply_result;
  wire [31 : 0] multiply_result$D_IN;
  wire multiply_result$EN;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_accumulator$write_1__VAL_1;

  // remaining internal signals
  wire [127 : 0] SEXT_mac_a_3_MUL_SEXT_mac_b_4___d15,
		 SEXT_multiply_a_MUL_SEXT_multiply_b___d3;
  wire [63 : 0] SEXT_SEXT_mac_a_3_MUL_SEXT_mac_b_4_5_BITS_63_T_ETC__q3,
		SEXT_SEXT_multiply_a_MUL_SEXT_multiply_b_BITS__ETC__q6,
		SEXT_mac_a_3_MUL_SEXT_mac_b_4_5_BITS_63_TO_0__q1,
		SEXT_multiply_a_MUL_SEXT_multiply_b_BITS_63_TO_0__q4;
  wire [47 : 0] SEXT_mac_a_3_MUL_SEXT_mac_b_4_5_BITS_63_TO_0_B_ETC__q2,
		SEXT_multiply_a_MUL_SEXT_multiply_b_BITS_63_TO_ETC__q5;

  // action method multiply
  assign RDY_multiply = RDY_clear_accumulator ;

  // actionvalue method get_multiply
  assign get_multiply = multiply_result ;
  assign RDY_get_multiply = busy_multiply ;

  // action method mac
  assign RDY_mac = RDY_clear_accumulator ;

  // actionvalue method get_mac
  assign get_mac = mac_result ;
  assign RDY_get_mac = busy_mac ;

  // action method clear_accumulator
  assign RDY_clear_accumulator = !busy_multiply && !busy_mac ;

  // value method busy
  assign busy = busy_multiply || busy_mac ;
  assign RDY_busy = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_accumulator$write_1__VAL_1 =
	     accumulator +
	     SEXT_SEXT_mac_a_3_MUL_SEXT_mac_b_4_5_BITS_63_T_ETC__q3[31:0] ;

  // register accumulator
  assign accumulator$D_IN = EN_mac ? MUX_accumulator$write_1__VAL_1 : 32'd0 ;
  assign accumulator$EN = EN_mac || EN_clear_accumulator ;

  // register busy_mac
  assign busy_mac$D_IN = !EN_get_mac ;
  assign busy_mac$EN = EN_get_mac || EN_mac ;

  // register busy_multiply
  assign busy_multiply$D_IN = !EN_get_multiply ;
  assign busy_multiply$EN = EN_get_multiply || EN_multiply ;

  // register mac_result
  assign mac_result$D_IN = EN_mac ? MUX_accumulator$write_1__VAL_1 : 32'd0 ;
  assign mac_result$EN = EN_mac || EN_clear_accumulator ;

  // register multiply_result
  assign multiply_result$D_IN =
	     SEXT_SEXT_multiply_a_MUL_SEXT_multiply_b_BITS__ETC__q6[31:0] ;
  assign multiply_result$EN = EN_multiply ;

  // remaining internal signals
  assign SEXT_SEXT_mac_a_3_MUL_SEXT_mac_b_4_5_BITS_63_T_ETC__q3 =
	     { {16{SEXT_mac_a_3_MUL_SEXT_mac_b_4_5_BITS_63_TO_0_B_ETC__q2[47]}},
	       SEXT_mac_a_3_MUL_SEXT_mac_b_4_5_BITS_63_TO_0_B_ETC__q2 } ;
  assign SEXT_SEXT_multiply_a_MUL_SEXT_multiply_b_BITS__ETC__q6 =
	     { {16{SEXT_multiply_a_MUL_SEXT_multiply_b_BITS_63_TO_ETC__q5[47]}},
	       SEXT_multiply_a_MUL_SEXT_multiply_b_BITS_63_TO_ETC__q5 } ;
  assign SEXT_mac_a_3_MUL_SEXT_mac_b_4_5_BITS_63_TO_0_B_ETC__q2 =
	     SEXT_mac_a_3_MUL_SEXT_mac_b_4_5_BITS_63_TO_0__q1[63:16] ;
  assign SEXT_mac_a_3_MUL_SEXT_mac_b_4_5_BITS_63_TO_0__q1 =
	     SEXT_mac_a_3_MUL_SEXT_mac_b_4___d15[63:0] ;
  assign SEXT_mac_a_3_MUL_SEXT_mac_b_4___d15 =
	     { {32{mac_a[31]}}, mac_a } * { {32{mac_b[31]}}, mac_b } ;
  assign SEXT_multiply_a_MUL_SEXT_multiply_b_BITS_63_TO_0__q4 =
	     SEXT_multiply_a_MUL_SEXT_multiply_b___d3[63:0] ;
  assign SEXT_multiply_a_MUL_SEXT_multiply_b_BITS_63_TO_ETC__q5 =
	     SEXT_multiply_a_MUL_SEXT_multiply_b_BITS_63_TO_0__q4[63:16] ;
  assign SEXT_multiply_a_MUL_SEXT_multiply_b___d3 =
	     { {32{multiply_a[31]}}, multiply_a } *
	     { {32{multiply_b[31]}}, multiply_b } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        accumulator <= `BSV_ASSIGNMENT_DELAY 32'd0;
	busy_mac <= `BSV_ASSIGNMENT_DELAY 1'd0;
	busy_multiply <= `BSV_ASSIGNMENT_DELAY 1'd0;
	mac_result <= `BSV_ASSIGNMENT_DELAY 32'd0;
	multiply_result <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (accumulator$EN)
	  accumulator <= `BSV_ASSIGNMENT_DELAY accumulator$D_IN;
	if (busy_mac$EN) busy_mac <= `BSV_ASSIGNMENT_DELAY busy_mac$D_IN;
	if (busy_multiply$EN)
	  busy_multiply <= `BSV_ASSIGNMENT_DELAY busy_multiply$D_IN;
	if (mac_result$EN)
	  mac_result <= `BSV_ASSIGNMENT_DELAY mac_result$D_IN;
	if (multiply_result$EN)
	  multiply_result <= `BSV_ASSIGNMENT_DELAY multiply_result$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    accumulator = 32'hAAAAAAAA;
    busy_mac = 1'h0;
    busy_multiply = 1'h0;
    mac_result = 32'hAAAAAAAA;
    multiply_result = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMAC