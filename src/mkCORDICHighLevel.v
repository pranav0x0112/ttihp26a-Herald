//
// Generated by Bluespec Compiler, version 2025.01.1-14-g36da7029 (build 36da7029)
//
// On Sat Dec 13 17:12:55 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_sin_cos                    O     1 const
// RDY_atan2                      O     1 const
// RDY_sqrt_magnitude             O     1 const
// RDY_multiply                   O     1 const
// get_sin_cos                    O    64 reg
// RDY_get_sin_cos                O     1
// get_atan2                      O    32 reg
// RDY_get_atan2                  O     1
// get_sqrt                       O    32 reg
// RDY_get_sqrt                   O     1
// get_multiply                   O    32 reg
// RDY_get_multiply               O     1
// busy                           O     1 reg
// RDY_busy                       O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// sin_cos_angle                  I    32
// atan2_y                        I    32
// atan2_x                        I    32
// sqrt_magnitude_x               I    32
// sqrt_magnitude_y               I    32
// multiply_a                     I    32
// multiply_b                     I    32
// EN_sin_cos                     I     1
// EN_atan2                       I     1
// EN_sqrt_magnitude              I     1
// EN_multiply                    I     1
// EN_get_sin_cos                 I     1
// EN_get_atan2                   I     1
// EN_get_sqrt                    I     1
// EN_get_multiply                I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCORDICHighLevel(CLK,
			 RST_N,

			 sin_cos_angle,
			 EN_sin_cos,
			 RDY_sin_cos,

			 atan2_y,
			 atan2_x,
			 EN_atan2,
			 RDY_atan2,

			 sqrt_magnitude_x,
			 sqrt_magnitude_y,
			 EN_sqrt_magnitude,
			 RDY_sqrt_magnitude,

			 multiply_a,
			 multiply_b,
			 EN_multiply,
			 RDY_multiply,

			 EN_get_sin_cos,
			 get_sin_cos,
			 RDY_get_sin_cos,

			 EN_get_atan2,
			 get_atan2,
			 RDY_get_atan2,

			 EN_get_sqrt,
			 get_sqrt,
			 RDY_get_sqrt,

			 EN_get_multiply,
			 get_multiply,
			 RDY_get_multiply,

			 busy,
			 RDY_busy);
  input  CLK;
  input  RST_N;

  // action method sin_cos
  input  [31 : 0] sin_cos_angle;
  input  EN_sin_cos;
  output RDY_sin_cos;

  // action method atan2
  input  [31 : 0] atan2_y;
  input  [31 : 0] atan2_x;
  input  EN_atan2;
  output RDY_atan2;

  // action method sqrt_magnitude
  input  [31 : 0] sqrt_magnitude_x;
  input  [31 : 0] sqrt_magnitude_y;
  input  EN_sqrt_magnitude;
  output RDY_sqrt_magnitude;

  // action method multiply
  input  [31 : 0] multiply_a;
  input  [31 : 0] multiply_b;
  input  EN_multiply;
  output RDY_multiply;

  // actionvalue method get_sin_cos
  input  EN_get_sin_cos;
  output [63 : 0] get_sin_cos;
  output RDY_get_sin_cos;

  // actionvalue method get_atan2
  input  EN_get_atan2;
  output [31 : 0] get_atan2;
  output RDY_get_atan2;

  // actionvalue method get_sqrt
  input  EN_get_sqrt;
  output [31 : 0] get_sqrt;
  output RDY_get_sqrt;

  // actionvalue method get_multiply
  input  EN_get_multiply;
  output [31 : 0] get_multiply;
  output RDY_get_multiply;

  // value method busy
  output busy;
  output RDY_busy;

  // signals for module outputs
  wire [63 : 0] get_sin_cos;
  wire [31 : 0] get_atan2, get_multiply, get_sqrt;
  wire RDY_atan2,
       RDY_busy,
       RDY_get_atan2,
       RDY_get_multiply,
       RDY_get_sin_cos,
       RDY_get_sqrt,
       RDY_multiply,
       RDY_sin_cos,
       RDY_sqrt_magnitude,
       busy;

  // register cordic_busy_reg
  reg cordic_busy_reg;
  wire cordic_busy_reg$D_IN, cordic_busy_reg$EN;

  // register cordic_state
  reg [103 : 0] cordic_state;
  reg [103 : 0] cordic_state$D_IN;
  wire cordic_state$EN;

  // register current_op
  reg [2 : 0] current_op;
  reg [2 : 0] current_op$D_IN;
  wire current_op$EN;

  // register operation_pending
  reg operation_pending;
  wire operation_pending$D_IN, operation_pending$EN;

  // register result_ready
  reg result_ready;
  reg result_ready$D_IN;
  wire result_ready$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_check_completion, WILL_FIRE_RL_cordic_do_iteration;

  // inputs to muxes for submodule ports
  wire [103 : 0] MUX_cordic_state$write_1__VAL_1,
		 MUX_cordic_state$write_1__VAL_2,
		 MUX_cordic_state$write_1__VAL_3,
		 MUX_cordic_state$write_1__VAL_4,
		 MUX_cordic_state$write_1__VAL_5;

  // remaining internal signals
  reg [31 : 0] CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1,
	       CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2;
  wire [39 : 0] IF_IF_cordic_state_BITS_2_TO_1_EQ_1_THEN_NOT_c_ETC___d36;
  wire [31 : 0] IF_cordic_state_BITS_2_TO_1_EQ_2_4_THEN_SEL_AR_ETC___d29,
		cordic_state_BITS_103_TO_72_3_SRA_cordic_state_ETC___d19,
		cordic_state_BITS_71_TO_40_SRA_cordic_state_BI_ETC___d15;
  wire IF_cordic_state_BITS_2_TO_1_EQ_1_THEN_NOT_cord_ETC___d12;

  // action method sin_cos
  assign RDY_sin_cos = 1'd1 ;

  // action method atan2
  assign RDY_atan2 = 1'd1 ;

  // action method sqrt_magnitude
  assign RDY_sqrt_magnitude = 1'd1 ;

  // action method multiply
  assign RDY_multiply = 1'd1 ;

  // actionvalue method get_sin_cos
  assign get_sin_cos = { cordic_state[71:40], cordic_state[103:72] } ;
  assign RDY_get_sin_cos =
	     result_ready && current_op == 3'd2 && cordic_state[0] ;

  // actionvalue method get_atan2
  assign get_atan2 = cordic_state[39:8] ;
  assign RDY_get_atan2 =
	     result_ready && current_op == 3'd3 && cordic_state[0] ;

  // actionvalue method get_sqrt
  assign get_sqrt = cordic_state[103:72] ;
  assign RDY_get_sqrt =
	     result_ready && current_op == 3'd4 && cordic_state[0] ;

  // actionvalue method get_multiply
  assign get_multiply = cordic_state[71:40] ;
  assign RDY_get_multiply =
	     result_ready && current_op == 3'd6 && cordic_state[0] ;

  // value method busy
  assign busy = cordic_busy_reg ;
  assign RDY_busy = 1'd1 ;

  // rule RL_check_completion
  assign WILL_FIRE_RL_check_completion =
	     operation_pending && !cordic_busy_reg && !result_ready ;

  // rule RL_cordic_do_iteration
  assign WILL_FIRE_RL_cordic_do_iteration =
	     cordic_busy_reg && !cordic_state[0] ;

  // inputs to muxes for submodule ports
  assign MUX_cordic_state$write_1__VAL_1 = { multiply_a, multiply_b, 40'd0 } ;
  assign MUX_cordic_state$write_1__VAL_2 =
	     { sqrt_magnitude_x, sqrt_magnitude_y, 40'd2 } ;
  assign MUX_cordic_state$write_1__VAL_3 = { atan2_x, atan2_y, 40'd2 } ;
  assign MUX_cordic_state$write_1__VAL_4 =
	     { 64'h00009B7500000000, sin_cos_angle, 8'd0 } ;
  assign MUX_cordic_state$write_1__VAL_5 =
	     { IF_cordic_state_BITS_2_TO_1_EQ_1_THEN_NOT_cord_ETC___d12 ?
		 cordic_state[103:72] +
		 cordic_state_BITS_71_TO_40_SRA_cordic_state_BI_ETC___d15 :
		 cordic_state[103:72] -
		 cordic_state_BITS_71_TO_40_SRA_cordic_state_BI_ETC___d15,
	       IF_cordic_state_BITS_2_TO_1_EQ_1_THEN_NOT_cord_ETC___d12 ?
		 cordic_state[71:40] -
		 cordic_state_BITS_103_TO_72_3_SRA_cordic_state_ETC___d19 :
		 cordic_state[71:40] +
		 cordic_state_BITS_103_TO_72_3_SRA_cordic_state_ETC___d19,
	       IF_IF_cordic_state_BITS_2_TO_1_EQ_1_THEN_NOT_c_ETC___d36 } ;

  // register cordic_busy_reg
  assign cordic_busy_reg$D_IN =
	     EN_multiply || EN_sqrt_magnitude || EN_atan2 || EN_sin_cos ;
  assign cordic_busy_reg$EN =
	     WILL_FIRE_RL_cordic_do_iteration && cordic_state[7:3] == 5'd31 ||
	     EN_multiply ||
	     EN_sqrt_magnitude ||
	     EN_atan2 ||
	     EN_sin_cos ;

  // register cordic_state
  always@(EN_multiply or
	  MUX_cordic_state$write_1__VAL_1 or
	  EN_sqrt_magnitude or
	  MUX_cordic_state$write_1__VAL_2 or
	  EN_atan2 or
	  MUX_cordic_state$write_1__VAL_3 or
	  EN_sin_cos or
	  MUX_cordic_state$write_1__VAL_4 or
	  WILL_FIRE_RL_cordic_do_iteration or MUX_cordic_state$write_1__VAL_5)
  case (1'b1)
    EN_multiply: cordic_state$D_IN = MUX_cordic_state$write_1__VAL_1;
    EN_sqrt_magnitude: cordic_state$D_IN = MUX_cordic_state$write_1__VAL_2;
    EN_atan2: cordic_state$D_IN = MUX_cordic_state$write_1__VAL_3;
    EN_sin_cos: cordic_state$D_IN = MUX_cordic_state$write_1__VAL_4;
    WILL_FIRE_RL_cordic_do_iteration:
	cordic_state$D_IN = MUX_cordic_state$write_1__VAL_5;
    default: cordic_state$D_IN =
		 104'hAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
  endcase
  assign cordic_state$EN =
	     WILL_FIRE_RL_cordic_do_iteration || EN_sin_cos || EN_atan2 ||
	     EN_sqrt_magnitude ||
	     EN_multiply ;

  // register current_op
  always@(EN_multiply or EN_sqrt_magnitude or EN_atan2 or EN_sin_cos)
  case (1'b1)
    EN_multiply: current_op$D_IN = 3'd6;
    EN_sqrt_magnitude: current_op$D_IN = 3'd4;
    EN_atan2: current_op$D_IN = 3'd3;
    EN_sin_cos: current_op$D_IN = 3'd2;
    default: current_op$D_IN = 3'b010 /* unspecified value */ ;
  endcase
  assign current_op$EN =
	     EN_sin_cos || EN_atan2 || EN_sqrt_magnitude || EN_multiply ;

  // register operation_pending
  assign operation_pending$D_IN =
	     EN_multiply || EN_sqrt_magnitude || EN_atan2 || EN_sin_cos ;
  assign operation_pending$EN =
	     WILL_FIRE_RL_check_completion || EN_multiply ||
	     EN_sqrt_magnitude ||
	     EN_atan2 ||
	     EN_sin_cos ;

  // register result_ready
  always@(EN_multiply or
	  EN_sqrt_magnitude or
	  EN_atan2 or
	  EN_sin_cos or
	  WILL_FIRE_RL_check_completion or
	  EN_get_multiply or EN_get_sqrt or EN_get_atan2 or EN_get_sin_cos)
  case (1'b1)
    EN_multiply || EN_sqrt_magnitude || EN_atan2 || EN_sin_cos:
	result_ready$D_IN = 1'd0;
    WILL_FIRE_RL_check_completion: result_ready$D_IN = 1'd1;
    EN_get_multiply || EN_get_sqrt || EN_get_atan2 || EN_get_sin_cos:
	result_ready$D_IN = 1'd0;
    default: result_ready$D_IN = 1'b0 /* unspecified value */ ;
  endcase
  assign result_ready$EN =
	     EN_get_multiply || EN_get_sqrt || EN_get_atan2 ||
	     EN_get_sin_cos ||
	     EN_multiply ||
	     EN_sqrt_magnitude ||
	     EN_atan2 ||
	     EN_sin_cos ||
	     WILL_FIRE_RL_check_completion ;

  // remaining internal signals
  assign IF_IF_cordic_state_BITS_2_TO_1_EQ_1_THEN_NOT_c_ETC___d36 =
	     { IF_cordic_state_BITS_2_TO_1_EQ_1_THEN_NOT_cord_ETC___d12 ?
		 cordic_state[39:8] +
		 IF_cordic_state_BITS_2_TO_1_EQ_2_4_THEN_SEL_AR_ETC___d29 :
		 cordic_state[39:8] -
		 IF_cordic_state_BITS_2_TO_1_EQ_2_4_THEN_SEL_AR_ETC___d29,
	       cordic_state[7:3] + 5'd1,
	       cordic_state[2:1],
	       cordic_state[7:3] == 5'd31 } ;
  assign IF_cordic_state_BITS_2_TO_1_EQ_1_THEN_NOT_cord_ETC___d12 =
	     (cordic_state[2:1] == 2'd1) ?
	       (cordic_state[71:40] ^ 32'h80000000) > 32'h80000000 :
	       cordic_state[39] ;
  assign IF_cordic_state_BITS_2_TO_1_EQ_2_4_THEN_SEL_AR_ETC___d29 =
	     (cordic_state[2:1] == 2'd2) ?
	       CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 :
	       CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 ;
  assign cordic_state_BITS_103_TO_72_3_SRA_cordic_state_ETC___d19 =
	     cordic_state[103:72] >> cordic_state[7:3] |
	     ~(32'hFFFFFFFF >> cordic_state[7:3]) & {32{get_sqrt[31]}} ;
  assign cordic_state_BITS_71_TO_40_SRA_cordic_state_BI_ETC___d15 =
	     cordic_state[71:40] >> cordic_state[7:3] |
	     ~(32'hFFFFFFFF >> cordic_state[7:3]) & {32{get_multiply[31]}} ;
  always@(cordic_state)
  begin
    case (cordic_state[7:3])
      5'd0:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 =
	      32'd147391456;
      5'd1:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 =
	      32'd69254785;
      5'd2:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 =
	      32'd34408521;
      5'd3:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 =
	      32'd17119964;
      5'd4:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 =
	      32'd8567219;
      5'd5:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 =
	      32'd4282395;
      5'd6:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 =
	      32'd2796722;
      5'd7:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 =
	      32'd1398361;
      5'd8:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd699051;
      5'd9:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd349611;
      5'd10:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd174763;
      5'd11:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd87381;
      5'd12:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd43691;
      5'd13:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd21845;
      5'd14:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd10923;
      5'd15:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd5461;
      5'd16:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd2731;
      5'd17:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd1365;
      5'd18: CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd683;
      5'd19: CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd341;
      5'd20: CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd171;
      5'd21: CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd85;
      5'd22: CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd43;
      5'd23: CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd21;
      5'd24: CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd11;
      5'd25: CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd5;
      5'd26: CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd2;
      5'd27: CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd1;
      5'd28, 5'd29, 5'd30, 5'd31:
	  CASE_cordic_state_BITS_7_TO_3_0_147391456_1_69_ETC__q1 = 32'd0;
    endcase
  end
  always@(cordic_state)
  begin
    case (cordic_state[7:3])
      5'd0:
	  CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd51471;
      5'd1:
	  CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd30385;
      5'd2:
	  CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd16054;
      5'd3: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd8149;
      5'd4: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd4091;
      5'd5: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd2047;
      5'd6: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd1024;
      5'd7: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd512;
      5'd8: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd256;
      5'd9: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd128;
      5'd10: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd64;
      5'd11: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd32;
      5'd12: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd16;
      5'd13: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd8;
      5'd14: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd4;
      5'd15: CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd2;
      5'd16, 5'd17:
	  CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd1;
      5'd18,
      5'd19,
      5'd20,
      5'd21,
      5'd22,
      5'd23,
      5'd24,
      5'd25,
      5'd26,
      5'd27,
      5'd28,
      5'd29,
      5'd30,
      5'd31:
	  CASE_cordic_state_BITS_7_TO_3_0_51471_1_30385__ETC__q2 = 32'd0;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cordic_busy_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	cordic_state <= `BSV_ASSIGNMENT_DELAY 104'hAAAAAAAAAAAAAAAAAAAAAAAAAA;
	current_op <= `BSV_ASSIGNMENT_DELAY 3'h2;
	operation_pending <= `BSV_ASSIGNMENT_DELAY 1'd0;
	result_ready <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (cordic_busy_reg$EN)
	  cordic_busy_reg <= `BSV_ASSIGNMENT_DELAY cordic_busy_reg$D_IN;
	if (cordic_state$EN)
	  cordic_state <= `BSV_ASSIGNMENT_DELAY cordic_state$D_IN;
	if (current_op$EN)
	  current_op <= `BSV_ASSIGNMENT_DELAY current_op$D_IN;
	if (operation_pending$EN)
	  operation_pending <= `BSV_ASSIGNMENT_DELAY operation_pending$D_IN;
	if (result_ready$EN)
	  result_ready <= `BSV_ASSIGNMENT_DELAY result_ready$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cordic_busy_reg = 1'h0;
    cordic_state = 104'hAAAAAAAAAAAAAAAAAAAAAAAAAA;
    current_op = 3'h2;
    operation_pending = 1'h0;
    result_ready = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkCORDICHighLevel

